%ul.content
  %li
    .label
      %h1
        Test topic label
      %p.date
        25.01.13
    .topic
      %p
        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
        Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
      = partial "partials/utils/picture", :locals => { :src => "global/dog.jpg" }
      = preserve do
        - code("c") do
          :plain
            static inline
            uint8_t decode ( bt_hash * hash, char * src, size_t src_length, uint8_t significant_bits, uint8_t padding_size, convert_char convert )
            {
                size_t bits = src_length * significant_bits;
                if ( bits % padding_size ) {
                    // not properly padded string
                    return 1;
                }

                int8_t ch;
                char * walk     = src;
                char * walk_end = src + src_length;

                while ( walk != walk_end ) {
                    walk_end--;
                    ch = *walk_end;
                    // bypass padding
                    if ( ch != '=' ) {
                        walk_end++;
                        break;
                    }

                    bits -= significant_bits;
                }

                if ( bits == 0 ) {
                    // all content is padding
                    return 2;
                }

                size_t   length       = bits >> 3; // bits / 8
                uint32_t buffer       = 0;
                uint8_t  buffer_size  = 0;

                size_t result_index = 0;
                uint8_t * result = hash->binary = talloc ( hash, sizeof ( uint8_t ) * length );
                if ( result == NULL ) {
                    return 3;
                }
                hash->length = length;

                while ( walk != walk_end ) {
                    buffer <<= significant_bits;
                    ch = convert ( * walk );
                    if ( ch == -1 ) {
                        return 4;
                    }
                    buffer |= ch;
                    buffer_size += significant_bits;

                    if ( buffer_size >= 8 ) {
                        result[result_index] = ( uint8_t ) ( buffer >> ( buffer_size - 8 ) );
                        buffer_size -= 8;
                        result_index++;
                    }

                    walk++;
                }

                return 0;
            }
      %a.more(href="#") Read more